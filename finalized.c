#pragma config(Sensor, in4,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl4,  Button,        sensorTouch)
#pragma config(Sensor, dgtl2,  Sonar,          sensorSONAR_mm)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           DoorMotor,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*************************************************************************
VEX Program -ENGR 120/121 Light sensor lab

Description: This program turns on an LED when the phototransistor is
exposed to a sufficiently large amount of infrared light.


Configuration: This program is written to work with the sensors constructed
as described in the ENGR 120/121 Lab 3 description.

	Breadboard connected to	- analog port 1 measures phototransistor
	                        - digital port 1 controls a red LED

*************************************************************************/
//the IR would always osciliate between the value that it scans and its default value
//since it wasnt fast enough to adjuct instantly and dynamically adjust its value
//this function compares the default value with the scanned value everytime the robot performs a check to ensure consistancy
int find_diff(){
	//this variable stores the minimum value recorded (scanned)
	int min = 10000;
	//and this one stores the resting IR value for each scan (as sometimes it can be finicy and give off diff values each scan)
	int max = -10000;
	//this for loop is active for 3x140msecs and goes through 3 scans at the same position
	for(int n = 0; n < 3; n++){
		if (SensorValue[InfraCollector] < min)min = SensorValue[InfraCollector];
		if (SensorValue[InfraCollector] > max)max = SensorValue[InfraCollector];
		wait1Msec(140);
	}
	//return the difference between resting and scanned values
	return max - min;
}

void orient(){
	//set motor speeds
	motor[LeftMotor] = 30;
	motor[RightMotor] = 30;
	//number of times the robot will go through the orient cycle in a direction aka how many sweeps it does
	int sweep = 0;
	//prev diff is the difference between the scanned and resting value from the past orientation loop
	int prev_diff = -1;

	while(true) {
		//store motor speed
	  //one of the motors is inverted so we cabn use the same speed as turning sopoeed for both
		int turn_speed = 30;
		//stop motors
		motor[LeftMotor] = 0;
		motor[RightMotor] = 0;
		//next diff is the difference between the scanned and resting value from the current orientation loop
		int next_diff = find_diff();

		//turn and check values
		if (prev_diff < 0) {
			//this is for the first check, thats why initially prev_diff = -1
			prev_diff = next_diff;
		} else {
				if (prev_diff <= next_diff) {
					prev_diff = next_diff;
				} else {
					if (sweep <= 1) {
						//this means we have completed one sweep and will prepare to switch directions and reset for the next sweep
						sweep++;
						//reset the IR scan values for nect sweep
						prev_diff = -1;
						//invert speed to start turning in the otehr direction
						turn_speed *= -1;
					} else {
						break;
					}
				}
			}

			//robot turns in 1 incrimant and repeats the loop to turn multipletimes
			//resume motors and pause to spin
			motor[LeftMotor] = turn_speed;
			motor[RightMotor] = turn_speed;
			wait1Msec(150);
		}
		//robot is aligned with target, stop and reset motors to 0
		motor[LeftMotor] = 0;
		motor[RightMotor] = 0;
}

//Thresholds for changes in robot behavior.
const int IR_SENSOR_THRESHOLD = 2500;
const int IR_SENSOR_THRESHOLD2 = 2300;

//Type of variable that will store the state values.
enum T_system_state
{
  STATE0 = 0, //initial state
  STATE1,     //searching state
  STATE2      //deposit state
};

task main()
{
	//System state variable
  T_system_state system_state;

  // Initialize system state
  system_state  = STATE0;

  //Endless loop
  while (true)
  {
  	//this is the switch with all our cases
  	switch(system_state)
    {
      //Management of system when in state 0
      case(STATE0):

        //searching for initial object signal
        motor[RightMotor] = 25; //have the motor running at 127 power
	    	motor[LeftMotor] = 25; //have the motor running at -127 power

        //When an infrared beam from the object hits
        if (SensorValue[InfraCollector] < IR_SENSOR_THRESHOLD && IR_SENSOR_THRESHOLD2 < SensorValue[InfraCollector])
        {
          //IR Light detected: Switch system state.
          system_state = STATE1;
        }
        break;

       case(STATE1):
       //motors stop to indicate state change
       motor[RightMotor] = 0;
	     motor[LeftMotor] = 0;
	     wait1Msec(500);

	     //as long as the robot is not close enough, keep reorienting
	     while( (SensorValue[InfraCollector] > IR_SENSOR_THRESHOLD2) ){
	     	  //move forward a little
	     		motor[LeftMotor] = -30;
	     		motor[RightMotor] = 30;
       	  wait1Msec(800);
       	  //reorient
       	  orient();
       	  //if we are really close
       	  if(SensorValue[InfraCollector] <= IR_SENSOR_THRESHOLD2){
       	  	//stop
       	  	break;
       	  }
	  }
	     //once IR threshold 2 is met and we are closer
	     if (SensorValue[InfraCollector] < IR_SENSOR_THRESHOLD2)
	     {
	      //switch to system state 2
	     	system_state = STATE2;
	    }

      case(STATE2):
			//motors stop to indicate state change
      motor[RightMotor] = 0;
	    motor[LeftMotor] = 0;
	     		wait1Msec(500);
	    //now start using sonar to see how close we are to platform
      while(SensorValue[Sonar] > 62){
       	motor[RightMotor] = 18;
	     	motor[LeftMotor] = -18;
	     }
	     //once loop is broken we are in place to deposit the ball
	     motor[RightMotor] = 0;
	     motor[LeftMotor] = 0;
	     wait1Msec(1000);
	     //open the door to allow the ball to drop
	     motor[DoorMotor] = 15;
			 wait1Msec(600);
			 //stop motors again to let ball settle
			 motor[RightMotor] = 0;
	     motor[LeftMotor] = 0;
	     wait1Msec(1000);
	     //drive back away from platform
			 motor[RightMotor] = -50;
	     motor[LeftMotor] = 50;
			 wait1Msec(400);
			 //close drop down door
			 motor[DoorMotor] = -25;
			 wait1Msec(400);
			 //stop everything
			 stopAllTasks();
			 break;
      //this is just in case something gets skiopped in the program
    	if (SensorValue(InfraCollector) > IR_SENSOR_THRESHOLD)
    	{
          // Switch system state.
          system_state = STATE0;
    	}

    	}

  }

}
